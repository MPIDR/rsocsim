<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SOCSIM oversimplified • rsocsim</title><script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="deps/headroom-0.11.0/headroom.min.js"></script><script src="deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="deps/search-1.0.0/fuse.min.js"></script><script src="deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="SOCSIM oversimplified"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="index.html">rsocsim</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.7.3</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/MPIDR/rsocsim/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-title-body">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>SOCSIM oversimplified</h1>
      <small class="dont-index">Source: <a href="https://github.com/MPIDR/rsocsim/blob/main/socsim_oversimplified.md" class="external-link"><code>socsim_oversimplified.md</code></a></small>
    </div>


<div id="socsim-oversimplified" class="section level1">

<div class="section level2">
<h2 id="table-of-content">Table of Content<a class="anchor" aria-label="anchor" href="#table-of-content"></a></h2>
<ul><li>
<a href="#socsim-oversimplified">SOCSIM oversimplified</a>
<ul><li><a href="#table-of-content">Table of Content</a></li>
</ul></li>
<li>
<a href="#first-encounter">First Encounter</a>
<ul><li><a href="#the-simplest-possible-simulation">The simplest possible simulation</a></li>
<li><a href="#what-goes-on-inside">What goes on inside</a></li>
</ul></li>
<li>
<a href="#extending-socsim">Extending Socsim</a>
<ul><li><a href="#groups">Groups</a></li>
</ul></li>
<li>
<a href="#marriage-market">Marriage Market</a>
<ul><li><a href="#the-two-queue-system">The two queue system</a></li>
<li><a href="#the-one-queue-system">The one queue system</a></li>
<li>
<a href="#evaluating-potential-marriages-score3">Evaluating potential marriages (score3())</a>
<ul><li><a href="#age-distribution-matching">Age distribution matching</a></li>
<li><a href="#in-practice">In practice …</a></li>
<li><a href="#age-preference">Age preference</a></li>
</ul></li>
</ul></li>
<li>
<a href="#supervisory-and-rate-files">Supervisory and rate files</a>
<ul><li><a href="#minimal-sup-file">Minimal .sup file</a></li>
<li><a href="#global-directives">Global Directives</a></li>
<li><a href="#id_14">14.</a></li>
<li><a href="#id_15">15</a></li>
<li><a href="#directives-used-in-extended-versions">Directives used in extended versions</a></li>
<li><a href="#segment-specific-directives">Segment specific directives</a></li>
</ul></li>
<li>
<a href="#population-files">Population files</a>
<ul><li><a href="#reckoning-kinship">Reckoning kinship</a></li>
<li><a href="#reference-to-marriages">Reference to marriages</a></li>
<li><a href="#reference-to-transition-history">Reference to transition history</a></li>
</ul></li>
<li>
<a href="#the-marriage-file">The marriage file</a>
<ul><li><a href="#reckoning-marriages">Reckoning marriages</a></li>
</ul></li>
<li><a href="#transition-history-files">Transition history files</a></li>
<li>
<a href="#specifying-demographic-rates">Specifying demographic rates</a>
<ul><li><a href="#rate-default-rules">Rate default rules</a></li>
<li><a href="#structure-of-vital-rates">Structure of vital rates</a></li>
<li><a href="#mortality-rates">Mortality rates</a></li>
<li><a href="#marriage-rates">Marriage rates</a></li>
<li><a href="#divorce-rates">Divorce rates</a></li>
<li><a href="#fertility-rates">Fertility rates</a></li>
<li>
<a href="#transition-rates">Transition rates</a>
<ul><li><a href="#duration-specific-transition-rates">Duration specific transition rates</a></li>
</ul></li>
<li><a href="#event-competition">Event competition</a></li>
<li><a href="#generating-potential-waiting-times">Generating potential waiting times</a></li>
</ul></li>
<li>
<a href="#heterogeneity-multipliers">Heterogeneity multipliers</a>
<ul><li><a href="#fertility-multiplier-fmult">Fertility multiplier (fmult)</a></li>
<li><a href="#inheritance-of-fertility-multipliers">Inheritance of Fertility Multipliers</a></li>
</ul></li>
</ul></div>
</div>
<div class="section level1">
<h1 id="first-encounter">First Encounter<a class="anchor" aria-label="anchor" href="#first-encounter"></a></h1>
<p>Originally written in the 1970s, Socsim continues to develop as a research tool constantly changing to meet the goals of new research projects. A slick graphic user interface has never been part of the plan<sup id="a1"><a href="#f1">1</a></sup>. As a consequence, users must be comfortable editing ascii files in order to use socsim.</p>
<p>Raising the barrier to first use still higher is Socsim’s insatiable appetite for input data. Because micro-simulation is about simulating a whole mess of “individuals”’ vital demographic events, Socsim needs a whole mess of age, sex, marital status, <strong><em>group</em></strong><sup id="a2"><a href="#f2">2</a></sup> and parity specific rates for births, deaths, marriages and change of group membership. There is of course, a default structure – for example if mortality rates are not specified for married males, Socsim will by default use those of single males of the same group. Or if parity specific fertility rates are not specified, Socsim will use the same rates for all parities. Still, a moderately complicated simulation will still require an <em>astonishing</em> number of rates.</p>
<div class="section level2">
<h2 id="the-simplest-possible-simulation">The simplest possible simulation<a class="anchor" aria-label="anchor" href="#the-simplest-possible-simulation"></a></h2>
<p>To run Socsim you must provide the following:</p>
<ul><li><p>A compiled version of Socsim.<br>
See <a href="lab.demog.berkeley.edu/socsim">lab.demog.berkeley.edu/socsim</a> if this has not already been taken care of.</p></li>
<li><p>An initial population and marriage file.<br>
Socsim reads and writes Population data in a specific format. Population (or <strong><em>.opop</em></strong> files) are further described in Section <a href="#sec:populationFile">5</a>. In order for Socsim to start, it is must find an <strong><em>initial population</em></strong> stored in this format. Generally individuals in this population will not be married, if the initial population has a marriage structure, then a marriage file (or <strong><em>.omar</em></strong>) will also be required. The marriage file format is described in Section <a href="#tab:marriagefile">[tab:marriagefile]</a>. The initial population need have no particular age or sex distribution<sup id="a3"><a href="#f3">3</a></sup>, since one usually runs Socsim for a hundred (simulated) years or more in order to convert the initial population into a population with a known and stable age structure before simulating the processes that are of real interest. This can be done differently, but not without added complication.</p></li>
<li>
<p>A <strong><em>supervisory or .sup file</em></strong>.<br>
The supervisory file generally named with <code>.sup</code> suffix is passed to Socsim on the command line. It must contain certain <strong><em>global parameters</em></strong> such as the number of simulation <strong><em>segments</em></strong>, name patterns of initial population and final population files, and either a complete set of vital demographic rates or else <strong><em>include</em></strong> statements specifying where to find files containing those rates. The full explanation of <strong><em>.sup</em></strong> file is in Section <a href="#sec:supFile">4</a>.</p>
<p>The minimal file, (from the <code>Sample</code> directory of the source code tree) is shown in Figure <a href="#fig:supSample">[fig:supSample]</a>.</p>
</li>
<li>
<p>vital demographic rates<br>
As noted previously, the vital demographic rates can be included within the supervisory file. But generally it is more convenient to store them in one or more separate files which are referred to in the supervisory file with an <code>include</code> directive.</p>
<p>The format in which the rates are given to Socsim is critical. Generally a set of rates for particular demographic event begins with an identifier such as:</p>
<p><strong>birth 1 F married 0</strong></p>
<p>which indicates that the following several lines will contain a complete set of age specific fertility rates for group 1 married females of parity 0.</p>
<p>Following the rate identifier will be one or more lines each of which contains three space-separated numbers. The first two indicate year and months of the <strong>upper age bound</strong> over which the rate is in effect. The two quantities are added together so “1 1” is equivalent in effect to “0 13”. Note that the first age category specified should NOT have “0 0” as its upper bound; an upper age bound of “0 1” would include the first month of life only. Age categories are otherwise flexible; one can specify some age categories that are as short as a single month, while others are many years or decades wide.</p>
<p>The rate, given in per month terms, is the third number.</p>
<p>rates can now end earlier or later than at 100 years. But no later than 200 years. For more details on specifying rates See Section <a href="#sec:rateFiles">8</a>.</p>
</li>
</ul><p>When all of the above bits are in place, Socsim can be <del>executed from the Unix shell:<br><code>/path/to/socsim supervisoryfile.sup 12345</code></del> The result will be a considerable amount of screen output indicating which options are set and how the simulation is proceeding. Or just a short complaint about an inconsistency in the various input files.</p>
<p>After a successful socsim run, a logfile called /user<span>supervisoryfile.sup12345.log</span> should be evident in the current directory as well as an output population <strong><em>.opop</em></strong>; marriage, <strong><em>.omar</em></strong> and perhaps a extra variables, <strong><em>.opox</em></strong> file whose locations depend on the <code>output_file</code> directive in the <strong><em>.sup</em></strong> file. Socsim also write an event history file</p>
<p>The <strong><em>.opop</em></strong>, <strong><em>.omar</em></strong> and <strong><em>.opox</em></strong> files produced by a Socsim run, are of course suitable initial population files(s) for subsequent Socsim simulations. Eventually however, you will probably have to stop simulating and start analyzing those files. See Sections <a href="#sec:populationFile">5</a>and <a href="#sec:marriageFile">6</a> for details on how these files are structured.</p>
</div>
<div class="section level2">
<h2 id="what-goes-on-inside">What goes on inside<a class="anchor" aria-label="anchor" href="#what-goes-on-inside"></a></h2>
<p>While all that “information” is scrolling past on the screen and filling the log file, Socsim is busily scheduling and executing vital demographic events for each simulated being in the initial population as well as all of their descendants.</p>
<p>Socsim begins each simulation <strong><em>segment</em></strong><sup id="a4"><a href="#f4">4</a></sup> by scheduling an event for each “living” person. At all times during the simulation every non dead simulated being has exactly one scheduled event. Whenever an event is executed or a person’s marital status or parity changes, a new event is scheduled for that individual. Thus death of a spouse causes a new event to be scheduled for the widow; a birth causes a new event to be scheduled for both the child and the mother.</p>
<p>To determine which event a person is to be scheduled for, Socsim generates a random waiting time for each event that the person is at risk of having. Obviously the user supplied age, sex, group, and marital status specific rates govern the process of random waiting time generation. Once all of the potential events have randomly generated waiting times associated with them, the earliest one is chosen and that event is scheduled. Information on the other possible events is discarded. In short, it’s a competing risks model. The probability of each event is independent of all other events and the earliest event is the only one that counts. See Section <a href="#sec:eventcomp">8.8</a> for more details.</p>
<p>Once each person has a scheduled event, Socsim starts to march through time. A list is created of all of the events scheduled for the first month of the simulation segment and each is drawn in random order and executed. When the execution of an event causes a new event to be scheduled (as most do) the resulting new event is either placed on the calendar for execution in a future month or if the waiting time is zero, it is inserted in the list of events waiting for execution in the current month and is drawn in random order.</p>
<p>When all of the events scheduled for the current month are executed, Socsim increments the month and repeats the event execution procedure just out lined. When the last month of the segment is completed, Socsim begins the next segment by reading the rate files and generating new events for all living people. If there is no subsequent segment, then Socsim finishes by writing the population (.opop), marriage (.oar), extra variables (.opox), and population pyramid (.pyr) files.</p>
</div>
</div>
<div class="section level1">
<h1 id="extending-socsim-outdated">Extending Socsim (outdated!)<a class="anchor" aria-label="anchor" href="#extending-socsim-outdated"></a></h1>
<p>Socsim is open source so modifying the code to take account of cultural norms, ethnological truths, or behavioral theories is encouraged. Since many Socsim based research projects require some kind of enhancement, the program is structured so as to encourage modification. It is possible to enhance Socsim without first gaining a deep knowledge of all the intricacies of the program by taking advantage of “hooks” that have been placed in the code and which call functions at key points in the execution. “Stub” versions of these functions can be found in the <code>enhancementNULL.c</code> file in the top of the source tree.</p>
<p>When Socsim is compiled with the proper command line arguments, functions in <code>enhancement.c</code> become part of the code. If your modifications can be contained within <code>enhancement.c</code>, then improvements and bug fixes to the main trunk of the code will not conflict with your project – probably.</p>
<p>Before you consider enhancing Socsim, however, you should first give a lot of serious thought to how you might manage to accomplish your goal <strong>without writing any C code</strong>. One approach for doing this is is to try to make clever use of the concept of <strong><em>groups</em></strong>, described below.</p>
<p>Another approach to email Carl Mason (<a href="mailto:carlm@demog.berkeley.edu" class="email">carlm@demog.berkeley.edu</a>) and see if maybe he’ll do the programming for you.</p>
<div class="section level2">
<h2 id="groups">Groups<a class="anchor" aria-label="anchor" href="#groups"></a></h2>
<p>Socsim implements <strong><em>groups</em></strong> by simply adding a variable to the population list. Every person is a member of exactly one group at all times. Group membership is determined at birth according to the rule given in <strong><em>child_inherits_group</em></strong> directive, but can change at any time according to age, sex, marital status, and group specific <strong><em>transition</em></strong> rates that the user specifies.</p>
<p>The group designation can be thought of as ethnicity, location, health status, wealth, education or any characteristic of a person that might or might not change according to a rate schedule.</p>
<p>Members of each group are subject to the same rates for vital events. That is the members of group 7 have fertility, mortality and nuptiality schedules that are independent of those of group 8. When an individual transitions from one group to another, she becomes subject to the new group’s rates and therefore must have a new event scheduled.</p>
<p>Socsim determines how many groups are in a simulation at the beginning of each segment by looking at both the starting population and the rates. If Socsim finds a person of group N in the initial population than it knows that there are at least N groups in the simulation. If it finds a mortality rate for members of group Q then it knows that there are at least Q groups.</p>
<p>Because of the default pattern of rates described in Section <a href="#sec:rateFiles">8</a>, it is possible to add groups to a simulation and only specify the rates for the group which differ from the those of the existing group.</p>
</div>
</div>
<div class="section level1">
<h1 id="marriage-market">Marriage Market<a class="anchor" aria-label="anchor" href="#marriage-market"></a></h1>
<p>The marriage event is greatly complicated by the need for two spouses. When a 27 year old female’s marriage event comes up, there must be a suitable male at hand<sup id="a5"><a href="#f5">5</a></sup> or else that marriage cannot be executed on time. The need for two spouses means that randomness alone is inadequate for assuring that the specified marriage rates are achieved.</p>
<p>More generally, one can meet <em>at most</em> two of the following three marriage market constraints:</p>
<ul><li><p>Female age specific nuptiality rates</p></li>
<li><p>Male age specific nuptiality rates</p></li>
<li><p>Distribution of spousal age differences</p></li>
</ul><p>Thus compromise is necessary and Socsim offers a choice of two: A “one” queue and a “two” queue system. In the <em>two queue</em> system male and female nuptiality rates determine the beginning of a marriage search: only egos who have initiated marriage searches can be married under this system. If no suitable potential spouses are available, the searcher must then wait in a queue. Because a suitable spouse must be waiting in order for a marriage event to be executed, generally one of the two spouses must be getting married <em>after</em> a delay of some time since the beginning of her search.</p>
<p>In the <em>one queue</em> system, only females have nuptiality rates. When a marriage event is executed under this system, the lucky bride chooses the best match from <em>all</em> living unmarried males. Thus under the one queue system, female nuptiality rates are generally met, and marriage markets can be made to optimize selections over even rare criteria. In the unmodified version of Socsim, only the distribution of the age difference between spouses is considered, but in principle the scoring algorithm could be made to optimize over a set of criteria.</p>
<p>The cost of this however are (1) no male marriage rates can be specified – males in the <em>one queue</em> scheme marry at the convenience of females – and (2) processing will be slower especially when populations are large.</p>
<div class="section level2">
<h2 id="the-two-queue-system">The two queue system<a class="anchor" aria-label="anchor" href="#the-two-queue-system"></a></h2>
<p>Under the legacy “two queue” scheme, the marriage event signals the beginning of a marriage <em>search</em>. If a suitable spouse is <em>already</em> waiting on the marriage queue, then the marriage is executed. If not, then ego’s marriage search fails and she is added to the marriage queue herself–where she will wait (subject to the risk of other events) until she is “selected” by a male suitor who is initiating a marriage search. Under this scheme, the specified nuptiality rates are seldom accomplished because would be spouses often spend time on the marriage queue. This scheme is symmetric with respect to sex. There is a marriage queue for each sex and each sex is treated identically.</p>
<p>If, when a marriage search is initiated, there are potential spouses waiting in the queue then each potential match is fist checked for allowability via the <code>marriage_allowable()</code> function and, if the match does not violate incest rules and the potential spouses have not been previously married, then the match is evaluated by the <code>score3()</code> function and the highest scoring match is executed.</p>
</div>
<div class="section level2">
<h2 id="the-one-queue-system">The one queue system<a class="anchor" aria-label="anchor" href="#the-one-queue-system"></a></h2>
<p>The second (newer) scheme is a “one queue” system under which the female marriage event triggers a search across <strong>all</strong> available males and the “best” one is immediately selected. Potential matches are evaluated in the same way as under the two queue system (via the <code>score3()</code> function), but many more potential matches are evaluated for each event.</p>
<p>The main advantage of the one queue system is that it generally achieves the specified female age specific marriage rates –even when female rates are high and populations are small. Achieving the female marriage rates allows for overall fertility rates to be achieved when marital and non marital fertility rates are different. This is major headache preventer.</p>
<p>A second advantage of the one queue system is that it allows for a wider range of marriage criteria to be optimized. This of course requires that Socsim be <em>extended</em> (See Section <a href="#sec:extending">2</a>), but since under the one queue system <em>every</em> marriageable male is examined for each female marriage event, even spouses with qualities that are quite rare in the population can be located. Under the two queue scheme one can only choose the best spouse from those who have already initiated but not completed a marriage search. This can be quite unsatisfactory if for example the simulation is of a marriage market in which the optimal spouse is a particular type of cousin.</p>
</div>
<div class="section level2">
<h2 id="evaluating-potential-marriages-score3">Evaluating potential marriages (score3())<a class="anchor" aria-label="anchor" href="#evaluating-potential-marriages-score3"></a></h2>
<p>Regardless of which marriage queue system is enabled, potential marriages are fist screened by the <code>marriage_allowable()</code> and then scored by the <code>score()</code> function.</p>
<p>The <code>marriage_allowable()</code>function, eliminates consanguineous marriages closer than cousins and remarriage of spouses who have previously been married to each other.</p>
<p>Potential allowable marriages are then evaluated by the <code>score3()</code> function. There are two variants built into Socsim, hooks are included in the code to make modification of the evaluation process “easy”.</p>
<div class="section level3">
<h3 id="age-distribution-matching">Age distribution matching<a class="anchor" aria-label="anchor" href="#age-distribution-matching"></a></h3>
<p>If <span class="upright"><code>marriage_eval</code></span> is set to “distribution” then Socsim seeks to select the marriage that most reduces the disparity between the <strong><em>target distribution of age differences at marriage</em></strong> and the <strong><em>observed distribution of age differences at marriage</em></strong>. The <code>score3()</code> function does this by keeping track of the spousal ages at marriage of all marriages in the simulation segment as well as a predetermined target distribution. Each potential marriage is assigned a score that indicates the degree to which the fit between the target and observed distribution would be changed by the marriage in question. The marriage that most reduces the unweighted sum of the differences between the fractions of marriages conducted at each spousal age difference (in single years) is then chosen.</p>
<p><strong>This variant is intended to be used with the one-queue</strong> system in which all living unmarried males are potential partners. In this situation then, Only female rates and the parameters of the target spousal age distribution determine marriage events. In other words, the age distribution matching scheme together with the “one queue” marriage market attempts to optimize the distribution of spousal age differences subject to the constraint that females marry according to their rate schedule.</p>
<p>When the age distribution matching scheme is paired with the two-queue marriage market, the constraint set is much more complicated and the results are uncertain.</p>
<p>Mechanically, the age distribution matching scheme is implemented in the following way:</p>
<ul><li><p>At the beginning of each simulation segment, a vector of “target” <em>proportions</em> of age distributions is constructed for each simulation group. This vector is derived from the normal distribution with parameters: <span class="upright"><code>agedif_marriage_mean</code></span> and <span class="upright"><code>agedif_marriage_sd</code></span>. It sums to 1 and represents that desired fraction of marriages to <strong>women</strong> of that group that should have the particular age difference at the time of marriage.</p></li>
<li><p>The marriage queue consists of a linked list of all males(females) who are eligible. Under the one-queue system this would be all males who are not presently married. Under the two-queue system, it consists of males (females) who have had unsuccessful marriage events–a marriage event triggered a marriage search but no suitable spouse was available at that time.</p></li>
<li><p>Note again that this marriage evaluation scheme is intended to be used with the one-queue marriage market under which each male is put on the queue at birth and upon execution of any event that subsequently makes him marriage eligible (e.g. divorce or death of spouse).</p></li>
<li>
<p>When <strong>under the one-queue system</strong>: a female has a marriage event, or <strong>under the two-queue</strong>: system an ego of <em>either</em> sex initiates a marriage search, each potential partnership is given a score based on the age difference between the potential groom and bride. That score is derived from Equation <a href="#eq:mscore">[eq:mscore]</a>. Note that the score can be either positive or negative. The match with the highest score is chosen. If more than one match has the same score, one is chosen at random. The result (intention) is that the match which most reduces the difference between the target and observed distribution of age differences at marriage is the one selected.</p>
<p>Socsim can be extended to use additional information in this scoring algorithm.</p>
<p>[</p>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo></mtd><mtd columnalign="right" style="text-align: right"><msub><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi mathvariant="normal">g</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow></msub><mo>−</mo><msub><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">e</mi></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo></mtd><mtd columnalign="right" style="text-align: right"><msub><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow></msub><mo>−</mo><mfrac><msub><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">f</mi></mrow></msub><msub><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">t</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow></msub></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \mathrm{agediff} &amp;=&amp; \mathrm{age}_{\mathrm{groom}} - \mathrm{age}_{\mathrm{bride}} \\    \label{eq:mscore}
    \mathrm{score} &amp;=&amp; \mathrm{target}_{\mathrm{agediff}} - \frac{\mathrm{count}_{\mathrm{agediff}}}{\mathrm{count}_{\mathrm{total}}}
  \end{aligned}</annotation></semantics></math><p>]</p>
</li>
<li><p>After each marriage is executed, the counts of marriages by female group and age difference is incremented.</p></li>
<li><p>At the end of the simulation, the accrued differences between the target and actual marriage age differences are reported.</p></li>
</ul></div>
<div class="section level3">
<h3 id="in-practice-">In practice …<a class="anchor" aria-label="anchor" href="#in-practice-"></a></h3>
<p>While the ’distribution’ system of marriage evaluation can in theory match both the female age specific marriage rates <em>and</em> the specified distribution of age differences at marriage, “reality” has many ways of defeating the scientist:</p>
<ul><li><p>Remarriage<br>
of widows and divorcees: In high mortality populations where widows remarry, this – particularly old widows, the average age difference at marriage can wind up being too low and the shape of the age difference distribution can diverge from normal.</p></li>
<li><p>Large mean age differences are difficult<br>
to achieve. If birth cohorts are roughly equal in size it is difficult to sustain a symmetric distribution of age difference at marriage when the mean is far from zero–unless a large fraction of people never marry.</p></li>
<li><p>Beware of exogamy<br>
If marriages happen between members of different groups and the different groups have significantly different vital rates, then a lot of strange things might happen. While Socsim does manage the age difference distribution separately for each group – it does so from a female perspective. That is the marriage age difference distribution for group N refers to the distribution of age differences at marriage (groom -bride) for marriages involving a <em>female of group N</em>. The male’s group membership is not considered.</p></li>
</ul></div>
<div class="section level3">
<h3 id="age-preference">Age preference<a class="anchor" aria-label="anchor" href="#age-preference"></a></h3>
<p>If <span class="upright"><code>marriage_eval</code></span> is set to “preference”, then <code>score3()</code> implements the “simple” age preference schedule. In this system, potential marriage are evaluated according to a fixed preference scheme. Marriages are preferred according to how close the spouses are in age to the <span class="upright"><code>marriage_peak_age</code></span> no attention is paid to the realized distribution of marriages.</p>
<p>After incest and endogamy/exogamy checks are complete, suitors who have not been eliminated, are assigned a score based on the groom’s age - bride’s age. If this age difference is greater than <span class="upright"><code>marriage_peak_age</code></span> than the score declines at a constant rate as the difference increases. If the age difference is <strong>less</strong> than <span class="upright"><code>marriage_peak_age</code></span> then the score declines at <span class="upright"><code>marriage_slope_ratio</code></span>* that constant rate as the age difference decreases.</p>
<p>Before giving yourself a bald spot over this, note that only the ordinal rank of this score matters because the spouse is chosen randomly only from among the maximum scoring suitors. The idea is simply to favor a certain optimal age difference and to allow for a preference for older or younger spouses. In most simulations the marriage rates – which determine the age at which people initiate a marriage search, are <strong>far</strong> more important in determining marriage patterns than are these marriage preference parameters. The default value for <span class="upright"><code>marriage_peak_age</code></span> is 36 months.</p>
<p>The <span class="upright"><code>marriage_slope_ratio</code></span> parameter determines the degree to which groom-older marriages are preferred to bride-older marriages. A value of 1.0 implies an equal preference score for an age difference that is x months from <span class="upright"><code>marriage_peak_age</code></span> regardless of whether the groom or bride is older. A value greater than 1 implies a that the preference score will decline faster as the brides age increases relative the the grooms – than it will as the groom’s age increases relative to the bride’s. The default value, 2, means that preference scores decline twice as fast with distance from <span class="upright"><code>marriage_peak_age</code></span> as the bride’s age increases relative the the groom’s.</p>
<p>The <span class="upright"><code>marriage_agedif_max</code></span> and <span class="upright"><code>marriage_agedif_min</code></span> simply exclude from consideration marriages where the age difference between the partners (groom age - bride age) is beyond the specified bounds.</p>
<p><strong>While it is possible to use this evaluation scheme with the one-queue marriage market, we have not tested it. This system is intended to be used with the the two-queue system.</strong></p>
</div>
</div>
</div>
<div class="section level1">
<h1 id="supervisory-and-rate-files">Supervisory and rate files<a class="anchor" aria-label="anchor" href="#supervisory-and-rate-files"></a></h1>
<p>The name of the <strong><em>supervisory file</em></strong>, generally with <code>.sup</code> suffix, is passed to Socsim on the command line. Socsim expects such a filename followed by a random number seed and will not run without these two command line arguments.</p>
<p>What Socsim expects to find in the supervisory file is a set of parameters and possibly rate specifications that allow it to run the simulation. The supervisory file has to either contain all of the information Socsim needs (aside from the random number seed) or else it must have <strong><em>include</em></strong> directives that tell Socsim where else to look. The <code>.sup</code> file must consist entirely of valid directives or comment lines. Comments are lines that begin with ’*’. Comments are ignored by Socsim.</p>
<p>The <strong><em>.sup</em></strong> file includes both global (affecting the entire simulation) and segment specific simulation parameters. The <span class="upright"><code>run</code></span> directive indicates the end of a set of segment specific parameters. When Socsim encounters a <span class="upright"><code>run</code></span> directive, it stops reading the <code>.sup</code> file and executes the simulation segment. When the segment’s execution is complete, Socsim returns to reading the <code>.sup</code> file where it left off. This has two important implications:</p>
<ol style="list-style-type: decimal"><li><p>If the directives for a segment are not followed by a <span class="upright"><code>run</code></span> directive, the segment will not be executed. Socsim will simply read the instructions for the next segment and execute those – assuming that they end with a <span class="upright"><code>run</code></span> directive.</p></li>
<li><p>Errors in a <code>.sup</code> file will not be caught until they are encountered. If there is an error in the specification of the (92^{nd}) segment, Socsim will execute the first 91 segments before it exiting abnormally.</p></li>
</ol><div class="section level2">
<h2 id="minimal-sup-file">Minimal .sup file<a class="anchor" aria-label="anchor" href="#minimal-sup-file"></a></h2>
<p>At a minimum the supervisory file must include only a few directives. Figure <a href="#fig:supSample">fig:supSample</a> shows a minimal but sufficient <strong><em>.sup</em></strong> file.</p>
<hr><div class="sourceCode" id="cb1"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="sc">**</span><span class="er">**********************************************************************</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="er">**</span> This is the simplest possible socsim .sup file. It will run a one</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="sc">**</span> segment simulation with starting population <span class="cf">in</span> test.opop and</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="sc">**</span> test.omar and ending population <span class="cf">in</span> test.out{.opop,.omar} The</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="sc">**</span> duration of the one and only <span class="st">"segment"</span> is <span class="dv">1200</span> months; the minimum</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="sc">**</span> birth interval is <span class="dv">24</span> months; heterogenous fertility is turned off;</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="sc">**</span> rate files are <span class="cf">in</span> ratefile.Lese.</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="sc">**</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="er">**</span> type [path to socsim] run.sup <span class="dv">12345</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="sc">**</span> to run socsim</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="sc">**</span><span class="er">**********************************************************************</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a>segments <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>input_file test</span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>output_file test.out</span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>duration <span class="dv">1200</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>include ratefile.Lese</span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>run</span></code></pre></div>
<hr></div>
<div class="section level2">
<h2 id="global-directives">Global Directives<a class="anchor" aria-label="anchor" href="#global-directives"></a></h2>
<p>Global directives can affect the entire simulation and <em>generally</em> do not change with each new segment. With the exception of <span class="upright"><code>segments</code></span>, <span class="upright"><code>input_file</code></span> and <span class="upright"><code>output_file</code></span>, however, it is possible to change global directives in a simulation segment. What “global” means is that socsim does <strong>not</strong> reinitialize these directives to their default settings at the beginning of each simulation segment–as it does for the “segment specific” directives described in Section <a href="#sec:segmentSpecific">4.4</a>.</p>
<p>This means that <strong>you can change most global directives within each simulation segment</strong>. If Socsim finds a global directive such as <span class="upright"><code>bint</code></span> or <span class="upright"><code>sex_ratio</code></span> after the first <span class="upright"><code>run</code></span> directive, it <strong>will</strong> change its behavior accordingly and the new behavior will persist until either the end of the simulation or until the directive is encountered again.</p>
<p><strong>Be aware</strong> that if you decide to change a global directive for a particular segent, <strong>the new value becomes the default</strong> for subsequent simulation segments. In the case of segment specific directives, the default values are reset at the start of a new segment.</p>
<table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th align="left">1. | segments | <em>int</em> | def: 0 | |———-|:————-:|——:|</th>
</tr></thead><tbody><tr class="odd"><td align="left">|input_file | <em>word</em> | def: none| |———-|:————-:|——:| <code>input_file initpop</code> Indicates where Socsim should look for the input files. The arguement of this directive is a stem from which complete filename paths are constructed. <code>input-file-stem</code>.opop will be the initial population file; <code>input-file-stem</code>.omar will be the initial marriage file. The initial marriage file need not exist if the initial population has no kinship structure.</td>
</tr><tr class="even"><td align="left">3.</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th>output_file</th>
<th align="center"><em>word</em></th>
<th align="right">def: none</th>
</tr></thead><tbody></tbody></table><p><code>output_file resultspop</code><br>
Indicates where Socsim should write output files. Just as with <span class="upright"><code>input_file</code></span> directive, Socsim expects the argument to be a file stem, from which Socsim can construct a complete path by simply appending a suffix. By default, the population and marriages files are only written at the end of the final segment and are called <code>output-file-stem</code>.opop and <code>output-file-stem</code>.omar. However, The <span class="upright"><code>write_output</code></span> directive below causes these files to be written at the end of a segment and modifies naming conventions to avoid overwriting.</p>
<ol start="4" style="list-style-type: decimal"><li>
</li></ol><table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th align="left">| proportion_male | <em>real</em> | def: 0.5112 | |———-|:————-:|——:| <code>proportion_male 0.5112</code> Indicates the proportion of births which are male. In order to preserve an early mistake, the directive <span class="upright"><code>sex_ratio</code></span> is a synonym for <span class="upright"><code>proportion_male</code></span>.</th>
</tr></thead><tbody><tr class="odd"><td align="left">|hetfert | <em>1/0</em> | def: 1| |———-|:————-:|——:| <code>hetfert 1</code> Enables the heterogeneous fertility feature (0 to disables it). If enabled, each female will have a beta distributed random variable by which her fertility is multiplied before random waiting times are generated. The result is a wider variation in sibling set size than would otherwise result. Note that the degree to which this fertility “multiplier” is inherited by daughters can be set by the user see <strong><em>alpha</em></strong> and <strong><em>beta</em></strong>.</td>
</tr><tr class="even"><td align="left">6.</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th>alpha,betaT</th>
<th align="center"><em>real</em></th>
<th align="right">def: 0.0, 1.0</th>
</tr></thead><tbody></tbody></table><p><code>alpha 1.0</code><br><code>betaT 0.0</code><br>
Determine the degree to which the fertility multiplier is inherited from each woman’s mother. See Section <a href="#secfmult">[secfmult]</a> for a complete description.</p>
<ol start="7" style="list-style-type: decimal"><li>
</li></ol><table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th align="left">| random_father | <em>0/1</em> | def: 0 | |———-|:————-:|——:| <code>random_father 0</code> Indicates whether or not births to unmarried women should have a father randomly assigned. The default value 0 means “no”. In this case the children of nonmarried/non-cohabiting mothers will have 0 as their father’s id.</th>
</tr></thead><tbody><tr class="odd"><td align="left">| random_father_min_age | <em>int</em> | def: 15| |———-|:————-:|——:| <code>random_father_min_age 15</code> Specifies the minimum age in years that males must be in order to be picked as fathers of children born to unmarried/non-cohabiging women. Constraints on marriageability e.g. incest constraints and endogamy constraints are also enforced with respect to random fathers, but marital status is ignored. The default value is 15. Obviously this is meaningless unless the <span class="upright"><code>random_father</code></span> is set to 1</td>
</tr><tr class="even"><td align="left">9.</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th>bint</th>
<th align="center"><em>int</em></th>
<th align="right">def: 9</th>
</tr></thead><tbody></tbody></table><p><code>bint 9</code><br>
The minimum birth interval. As a concession to reality, Socsim can impose a minimum number of months between births. For humans 9 months is a good number to use. Socsim adjusts the specified fertility rates upward to compensate for the birth interval.</p>
<ol start="10" style="list-style-type: decimal"><li>
</li></ol><table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th align="left">| endogamy | <em>(-1..1)</em> | def: 0| |———-|:————-:|——:| <code>endogamy 0</code> Determines how suitors from other <strong><em>groups</em></strong> are treated in determining suitability for marriage. When ego is having a marriage event executed, s/he inspects everyone on the marriage queue of the opposite sex. A value of <span class="upright"><code>endogamy</code></span> between 0 and 1 is taken as the probability that a potential spouse who is a member of a <em>different</em> group from that of ego will be rejected. A value of 1 therefore implies <em>endogamy</em> while a value of 0 implies that group membership will not matter with respect to marriage. A value of <span class="upright"><code>endogamy</code></span> between -1 and 0 is taken as the negative of the probability that a potential spouse from the <strong>same group</strong> will be rejected. A value of -1 therefore enforces complete <em>exogamy</em> – all suitors of ego’s own group will be rejected with probability 1.</th>
</tr></thead><tbody><tr class="odd"><td align="left">| marriage_queues | <em>1 or 2</em> | def: 2| |———-|:————-:|——:| <code>marriage_queues 2</code> Determines which of the two possible marriage market schemes will be used. A “1” indicates that the <strong><em>one-queue</em></strong> system will be employed. Under this system <strong><em>all marriage-eligible males</em></strong> are evaluated for each female with a scheduled marriage event. A “2” indicates that the <strong><em>two-queue</em></strong> marriage market system will be used. In that case, both males and females have stochastically scheduled marriage (search) events and both sexes wait in their respecitve marriage queues if no suitable partner is immediately available. See Section <a href="#sec:marriageQueue">3</a> for a longer explanation</td>
</tr><tr class="even"><td align="left">12.</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th>marriage_eval</th>
<th align="center"><em>preference/distribution</em></th>
<th align="right">def: preference</th>
</tr></thead><tbody></tbody></table><p><code>marriage_eval preference</code><br>
Determines the method of evaluating potential marriages. “preference” indicates that the legacy age difference preference schedule be used. That scheme favors marriages based on their closeness to an ideal age difference. (See <span class="upright"><code>marriage_peak_age</code></span> and <span class="upright"><code>marriage_slope_raio</code></span>). “distribution” indicates that socsim should attempt to match a target distribution of the age difference between spouses at marriage. See <span class="upright"><code>agedif_marriage_mean</code></span> and <span class="upright"><code>agedif_marriage_sd</code></span>. Also see Section <a href="#sec:score3">3.3</a> for a lengthier explanation of all this.</p>
<ol start="13" style="list-style-type: decimal"><li>
</li></ol><table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th align="left">| agedif_marriage_mean group | <em>real</em> | def: all groups 2.0 |———-|:————-:|——:| <code>agedif_marriage_mean 1 2</code> Determines the mean (in <strong>years</strong> ) of the target distribution of spousal age differences for <strong><em>women</em> of the specified group.</strong> This directive consists of the word <span class="upright"><code>agedif_marriage_age_mean</code></span> followed by an integer indicating the group to which the directive applies and a real indicating the target mean spousal age difference in years. Currently Socsim uses a normal distribution as the target distribution. We await theoretically robust arguments in favor other parametric distributions. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “distribution”</strong> See Section <a href="#sec:score3">3.3</a> for more details.</th>
</tr></thead><tbody><tr class="odd"><td align="left">| agedif_marriage_sd | <em>int real &gt; 0</em> | def: all groups 3 | |———-|:————-:|——:| <code>agedif_marriage_sd 1 3</code> Determines the standard deviation of the target spousal age distribution. Just as with <span class="upright"><code>agedif_marriage_mean</code></span>, this directive is specified separately for each group in the simulation. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “distribution”.</strong> See Section <a href="#sec:score3">3.3</a> for more details.</td>
</tr><tr class="even"><td align="left">15</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th><span class="upright"><code>marriage_peak_age</code></span></th>
<th align="center"><em>int</em></th>
<th align="right">def: 36</th>
</tr></thead><tbody></tbody></table><p><code>marriage_peak_age 36</code><br>
Determines (together with <span class="upright"><code>marriage_slope_ratio</code></span>) the preference for spousal age <strong>difference</strong> (in months) among spouses. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “preference”</strong>. See Section <a href="#sec:score3">3.3</a> for more details.</p>
<table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><thead><tr class="header"><th>|marriage_slope_ratio |<em>real</em> |def: 2| |———-|:————-:|——:| <code>marriage_slope_ratio 2.0</code> Works with <span class="upright"><code>marriage_peak_age</code></span> to determine a marriage preference “score” for potential spouses. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “preference”</strong>. See Section <a href="#sec:score3">3.3</a> for more details.</th>
</tr></thead><tbody><tr class="odd"><td>|marriage_agedif_min | <em>int</em> |def: -120| |———-|:————-:|——:| <code>marriage_agedif_min -120</code> Determines the <em>lower</em> end of the permissible age difference between spouses (groom age - bride age), in months. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “preference”</strong> See Section <a href="#sec:score3">3.3</a> for more details.</td>
</tr></tbody></table><table class="table"><thead><tr class="header"><th>marriage_agedif_max</th>
<th align="center"><em>int</em></th>
<th align="right">def: 120</th>
</tr></thead><tbody></tbody></table><p><code>marriage_agedif_max 120</code><br>
Determines the <em>upper</em> end of the permissible age difference between spouses (groom age - bride age), in months. This is <strong>only valid if <span class="upright"><code>marriage_eval</code></span> is set to “preference”</strong> See Section <a href="#sec:score3">3.3</a> for more details.</p>
<table style="width:8%;" class="table"><colgroup><col width="8%"></colgroup><tbody><tr class="odd"><td>|child_inherits_group |rule |def: from_mother| |———-|:————-:|——:| <code>child_inherits_group from_mother</code> Determines how group membership is assigned at birth. Socsim understands the following rules:</td>
</tr><tr class="even"><td>- from_mother</td>
</tr><tr class="odd"><td>- from_father</td>
</tr><tr class="even"><td>- from_same_sex_parent</td>
</tr><tr class="odd"><td>- from_opposite_sex_parent</td>
</tr><tr class="even"><td>- (n) where (n) is a group to which all new borns are assigned.</td>
</tr><tr class="odd"><td>By default, Socsim assigns newborns to mother’s group. That is, if no option is specified, Socsim will use “from_mother”.</td>
</tr></tbody></table></div>
<div class="section level2">
<h2 id="directives-used-in-extended-versions">Directives used in extended versions<a class="anchor" aria-label="anchor" href="#directives-used-in-extended-versions"></a></h2>
<p>A few directives are included for convenience when extending SOCSIM. in the plain version of SOCSIM, none of these directives should be set.</p>
<ol start="20" style="list-style-type: decimal"><li>
<table class="table"><thead><tr class="header"><th><code>parameter0..parameter5</code></th>
<th align="center"><em>r</em></th>
<th align="right">def: none</th>
</tr></thead><tbody></tbody></table><p><span class="upright"><code>parameter0</code></span> through <code>parameter5</code> should be set only if the enhanced version of Socsim that you are using defines what they do.</p>
</li>
<li>
<table class="table"><thead><tr class="header"><th>read_xtra</th>
<th align="center"><em>1/0</em></th>
<th align="right">def: 0</th>
</tr></thead><tbody></tbody></table><p>Causes Socsim read a file called <span class="upright"><code>input-file-stem</code></span>.opox or crash if the file does not exist. The .opox file should contains a set of <span class="upright"><code>extra variable</code></span> values for each person in the initial population. This will generally only be used in versions of Socsim that have been modified. See Section <a href="#sec:modification">sec:modification</a> for description of the programming hooks available for “easy” modification. The plain vanilla version of Socsim does not use extra variables so reading them will not generally cause anything useful to happen.</p>
</li>
<li>
<table class="table"><thead><tr class="header"><th>size_of_extra</th>
<th align="center"><em>int</em></th>
<th align="right">def: 0</th>
</tr></thead><tbody></tbody></table><p>Determines is the number of variables that should be read for each person from the .opox file. This will generally be made to default when one modifies Socsim. In its unmodified state, Socsim does not use extra variables, so this directive is very infrequently what you are looking for.</p>
</li>
</ol></div>
<div class="section level2">
<h2 id="segment-specific-directives">Segment specific directives<a class="anchor" aria-label="anchor" href="#segment-specific-directives"></a></h2>
<p>These directives make sense if specified for each simulation segment.</p>
<ol style="list-style-type: decimal"><li>
<table class="table"><thead><tr class="header"><th>duration</th>
<th align="center"><em>int</em></th>
<th align="right">def: no default</th>
</tr></thead><tbody></tbody></table><p>Determines the duration in months of the current simulaion segment.</p>
</li>
<li>
<table class="table"><thead><tr class="header"><th>include</th>
<th align="center"><em>filename</em></th>
<th align="right">def: none</th>
</tr></thead><tbody></tbody></table><p>Socsim will read and parse <code>filename</code> as if it were part of the current file. It is strongly recommended that <span class="upright"><code>include</code></span> be used to keep rate specifications separate from the rest of the simulation parameters. See Section <a href="#sec:rateFiles">8</a> has details on how vital demographic rates are specified.</p>
</li>
<li>
<table class="table"><thead><tr class="header"><th>execute</th>
<th align="center"><em>Unix shell command</em></th>
<th align="right">def: none</th>
</tr></thead><tbody></tbody></table><p>The specified command is passed to the Unix shell and its output is routed to the screen. After the command exits without error, Socsim returns to processing the current file.</p>
</li>
</ol><p>It is possible with this directive to call an external program that might perhaps generate rate sets on the fly perhaps in response to the previous simulation segment. For example:</p>
<pre><code>  execute generate_rates 1 5 0 &gt;mortality.seg4
  include mortality.seg4</code></pre>
</div>
</div>
<div class="section level1">
<h1 id="population-files">Population files<a class="anchor" aria-label="anchor" href="#population-files"></a></h1>
<p>Socsim reads and writes everything it knows about people in two files: the population <strong><em>.opop</em></strong> file and the marriage <strong><em>.omar</em></strong> file<sup id="a6"><a href="#f6">6</a></sup>. Both are space delimited files and both contain only numbers.</p>
<p>Since one generally runs Socsim for 200 simulated years in order to start from a population with a known and stable age structure, it is seldom necessary to construct an initial population with any information other than the age and sex of a small number of individuals. Such a file can be easily constructed in a spreadsheet program. The coresponding marriage file is simply an empty file with correct name.</p>
<p>One needs to come to terms with the structure of the .opop and .omar files in much more detail when analyzing simulation output. A snipet of code for reading an .opop file into R is given in Figure <a href="#fig:readOpop">[fig:readOpop]</a>. In terms of R the .opop file’s contents fit naturally into a <strong><em>data.frame</em></strong> with 14 columns all of which are numerical. In more general terms, the .opop file is a matrix where each row contains information on a single person and each column contains a particular bit of infromation on each person.</p>
<p>Although it’s structure suggests that a .opop file might be right at home in a spreadsheet program, this is not so. First the files tend to be too large since they include not only a row for each person who ever lived. Even a modest sized simulation can easily have 100,000 rows. But more important, much of the information in the .opop file consists of identification numbers of other people. In other words the opop file is a multiply linked list. For manipulating linked lists, spreadsheets are profoundly suboptimal.</p>
<hr><div class="sourceCode" id="cb3"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="do">## read .opop into dataframe the .opop file contains one row for each</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="do">## simulated person who ever "lived". It generally includes many who</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="do">## "died" long ago.</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>opop<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="at">file=</span><span class="st">"../SimResults/example.opop"</span>,<span class="at">header=</span>F,<span class="at">as.is=</span>T)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="do">## assign names to columns</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="fu">names</span>(opop)<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"pid"</span>,<span class="st">"fem"</span>,<span class="st">"group"</span>,</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>               <span class="st">"nev"</span>,<span class="st">"dob"</span>,<span class="st">"mom"</span>,<span class="st">"pop"</span>,<span class="st">"nesibm"</span>,<span class="st">"nesibp"</span>,</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>               <span class="st">"lborn"</span>,<span class="st">"marid"</span>,<span class="st">"mstat"</span>,<span class="st">"dod"</span>,<span class="st">"fmult"</span>)</span></code></pre></div>
<hr><p><span id="fig:readOpop" label="fig:readOpop">[fig:readOpop]</span></p>
<p>In most cases, the .opop file will be sorted in order of person id and since person ids are sequential integers assigned in birth order this means that the .opop file is generally sorted in birth order, with the row number often being the same as the person id. This is not however guaranteed to be the case so check that it is so before relying on it<sup id="a7"><a href="#f7">7</a></sup> .</p>
<p>Table <a href="#tab:opop">tab:opop</a> shows which information is in each column.</p>
<table class="table"><colgroup><col width="11%"><col width="7%"><col width="80%"></colgroup><thead><tr class="header"><th align="right"><strong>position</strong></th>
<th align="left"><strong>name</strong></th>
<th align="left"><strong>description</strong></th>
</tr></thead><tbody><tr class="odd"><td align="right">1</td>
<td align="left">pid</td>
<td align="left">Person id unique identifier assigned as integer in birth order</td>
</tr><tr class="even"><td align="right">2</td>
<td align="left">fem</td>
<td align="left">1 if female 0 if male</td>
</tr><tr class="odd"><td align="right">3</td>
<td align="left">group</td>
<td align="left">Group identifier 1..60 current group membership of individual</td>
</tr><tr class="even"><td align="right">4</td>
<td align="left">nev</td>
<td align="left">Next scheduled event</td>
</tr><tr class="odd"><td align="right">5</td>
<td align="left">dob</td>
<td align="left">Date of birth integer month number</td>
</tr><tr class="even"><td align="right">6</td>
<td align="left">mom</td>
<td align="left">Person id of mother</td>
</tr><tr class="odd"><td align="right">7</td>
<td align="left">pop</td>
<td align="left">Person id of father</td>
</tr><tr class="even"><td align="right">8</td>
<td align="left">nesibm</td>
<td align="left">Person id of next eldest sibling through mother</td>
</tr><tr class="odd"><td align="right">9</td>
<td align="left">nesibp</td>
<td align="left">Person id of next eldest sibling through father</td>
</tr><tr class="even"><td align="right">10</td>
<td align="left">lborn</td>
<td align="left">Person id of last born child</td>
</tr><tr class="odd"><td align="right">11</td>
<td align="left">marid</td>
<td align="left">Id of marriage in .omar file</td>
</tr><tr class="even"><td align="right">12</td>
<td align="left">mstat</td>
<td align="left">Marital status at end of simulation integer 1=single;2=divorced; 3=widowed; 4=married</td>
</tr><tr class="odd"><td align="right">13</td>
<td align="left">dod</td>
<td align="left">Date of death or 0 if alive at end of simulation</td>
</tr><tr class="even"><td align="right">14</td>
<td align="left">fmult</td>
<td align="left">Fertility multiplier</td>
</tr></tbody></table><p>contents and format of the .opop file<span id="tab:opop" label="tab:opop"></span></p>
<div class="section level2">
<h2 id="reckoning-kinship">Reckoning kinship<a class="anchor" aria-label="anchor" href="#reckoning-kinship"></a></h2>
<p>In analyzing Socsim output, one is often interested in reckonning kinship. Since with the possible exception of the initial population, everyone in socsim is related to everyone else, it is possible to find nearly any two people’s relationship by following the chain of parents and siblings. To find ego’s maternal grandmother, one simply finds the ego’s mother’s person id in the (6^{th}) column of ego’s row in the opop file. Moving then to the row of the opop file coresponding to ego’s mother’s person id, one look’s again in the (6^{th}) column to find egos’ mother’s mother’s person id.</p>
<p>To find all of ego’s children, one starts with the person id of ego’s last born child (stored in column 10) of egos’ row of opop. In the row coresponding to ego’s last born child’s row of opop, we find, in column 8 (9), ego’s last born child’s next eldest sibling through her mother (father). In that person’s row of the .opop file, we can find yet another next eldest sibling and so on until we find ego’s first born child, whose next eldest sibling through mother (assuming that ego is female) is necessarily zero.</p>
<p>Alternatively, one could simply collect all the rows of opop which have that same value in column 6 (mom) and or 7(dad) as ego has.</p>
<p>The R computing environment (<a href="http://www.r-project.org" class="external-link uri">http://www.r-project.org</a>is particularly well suited for doing this kind of analysis of kinship.</p>
</div>
<div class="section level2">
<h2 id="reference-to-marriages">Reference to marriages<a class="anchor" aria-label="anchor" href="#reference-to-marriages"></a></h2>
<p>Since individuals can be married more than once (simultaneously in some cases) reckoning marriage information is trickier than working with kinship alone. See Section <a href="#marriageFile">[marriageFile]</a> for more details on how to work with Socsim’s .omar file. For the present purpose note that column 11 of the .opop file contains a pointer, in the form of a marriage id number, to ego’s most recent marriage. If column 11 is zero, then ego has never been married.</p>
</div>
<div class="section level2">
<h2 id="reference-to-transition-history">Reference to transition history<a class="anchor" aria-label="anchor" href="#reference-to-transition-history"></a></h2>
<p>If the simulation includes group transitions, than socsim will write a file with the same path as the population and marriage files but with the suffix <strong><em>.otx</em></strong>. The transition events do not have unique ids as do marriages, but each transition record contains the person id of the protagonist. Consequently it is much more natural to link from the transition history to the population file.</p>
<p>Section <a href="#otxFile">[otxFile]</a> describes the <strong><em>otx</em></strong> file in detail.</p>
</div>
</div>
<div class="section level1">
<h1 id="the-marriage-file">The marriage file<a class="anchor" aria-label="anchor" href="#the-marriage-file"></a></h1>
<p>The marriage (.omar) file is similar to the population (.opop) file in that much of the information it maintains is in the form of unique id numbers that corespond to rows of the .opop file or to the .omar file itself. In other words, the .omar file is another <em>linked list</em></p>
<p>Figure <a href="#fig:readOmar">[fig:readOmar]</a> shows a snippet of R code suitable for reading a .omar file. Table <a href="#tab:marriagefile">[tab:marriagefile]</a> shows the meaning of each column of the file.</p>
<div class="section level2">
<h2 id="reckoning-marriages">Reckoning marriages<a class="anchor" aria-label="anchor" href="#reckoning-marriages"></a></h2>
<p>As with the .opop file, reckoning marriage histories requires following a list of integers from one record (row) to another. The marriage id of the wife’s <em>most recent prior</em> marriage is stored in column 7. The coresponding pointer for the husband is stored in column 8. The other six columns of the marriage record hold information on the marriage itself. Note that marriages are created sequentially, but monogamy is not assumed. So for any particular marriage record, the wife’s prior marriage (pointed to in column 7) must have a start date (column 4) that is no larger (later) than that of the particular marriage. A “prior marriage” must start before (or in socsim, at least in the same month) as the subsequent marriage. But the same is not true for the marriage end date, which is stored in column 5.</p>
<p>Also, be careful of zeros. Marriages that remained intact when the simulation ended have end dates of zero.</p>
<p>To find a female ego’s first husband, one begins with the .opop file. The (11^{th}) column of ego’s row holds the marriage id of egos most recent marriage. The row in the .omar file whose first column entry matches that number is the record of egos’ most recent or “last” marriage. In order to find her <strong>first</strong> marriage, we must locate the row of the .omar file wherein the entry in column 1 matches the the marriage id of the wifes prior marriage which is stored in column 7 of the .omar file. We repeat this proces until we locate a record of a marriage for which ego’s person id is stored in the second column and column 7 holds a zero.</p>
<p>In R, a more efficient way of finding first marriages is to select the subset of marriages for which either the husband’s prior or wife’s prior marriage (column 7 or column 8) are zero, and then use the <code><a href="https://rdrr.io/r/base/match.html" class="external-link">match()</a></code> function to link the marriage id to the husband or wife’s opop record. Figure <a href="#fig:firstMarriages">[fig:firstMarriages]</a> shows a snippet of R code that performs this task.</p>
<hr><div class="sourceCode" id="cb4"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>omar<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="at">file=</span><span class="st">"../SimResults/example.omar"</span>,<span class="at">header=</span>F,<span class="at">as.is=</span>T)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">names</span>(omar)<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"mid"</span>,<span class="st">"wpid"</span>,<span class="st">"hpid"</span>,<span class="st">"dstart"</span>,<span class="st">"dend"</span>,</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>               <span class="st">"rend"</span>,<span class="st">"wprior"</span>,<span class="st">"hprior"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>   </span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="fu">rownames</span>(omar)<span class="ot">&lt;-</span>omar<span class="sc">$</span>mid</span></code></pre></div>
<p>label<span>fig:readOmar</span></p>
<table class="table"><colgroup><col width="13%"><col width="9%"><col width="76%"></colgroup><thead><tr class="header"><th align="right"><strong>position</strong></th>
<th align="left"><strong>name</strong></th>
<th align="left"><strong>description</strong></th>
</tr></thead><tbody><tr class="odd"><td align="right">1</td>
<td align="left">mid</td>
<td align="left">Marriage id number (unique sequential integer)</td>
</tr><tr class="even"><td align="right">2</td>
<td align="left">wpid</td>
<td align="left">Wife’s person id</td>
</tr><tr class="odd"><td align="right">3</td>
<td align="left">hpid</td>
<td align="left">Husband’s person id</td>
</tr><tr class="even"><td align="right">4</td>
<td align="left">dstart</td>
<td align="left">Date marriage began</td>
</tr><tr class="odd"><td align="right">5</td>
<td align="left">dend</td>
<td align="left">Date marriage ended or zero if still in force at end of simulation</td>
</tr><tr class="even"><td align="right">6</td>
<td align="left">rend</td>
<td align="left">Reason marriage ended 2 = divorce; 3 = death of one partner</td>
</tr><tr class="odd"><td align="right">7</td>
<td align="left">wprior</td>
<td align="left">Marriage id of wife’s next most recent prior marriage</td>
</tr><tr class="even"><td align="right">8</td>
<td align="left">hprior</td>
<td align="left">Marriage id of husband’s next most recent prior marriage</td>
</tr></tbody></table><p>Structure of Socsim marriage file<span label="tab:marriagefile"></span></p>
<hr><pre><code><span><span class="co">## get first marriage id -- socsim stores marriage ids as linked list</span></span>
<span><span class="co">## headed by most recent marriage.  The (h/w)prior field stores the id</span></span>
<span><span class="co">## of each spouses prior marriage</span></span>
<span></span>
<span><span class="co">## select a subset of marriages which are first for at least one partner</span></span>
<span><span class="va">fomar</span><span class="op">&lt;-</span><span class="va">omar</span><span class="op">[</span><span class="va">omar</span><span class="op">$</span><span class="va">hprior</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">|</span> <span class="va">omar</span><span class="op">$</span><span class="va">wprior</span> <span class="op">==</span> <span class="fl">0</span>,<span class="op">]</span></span>
<span><span class="va">opop</span><span class="op">$</span><span class="va">fmid</span><span class="op">&lt;-</span><span class="cn">NA</span></span>
<span></span>
<span><span class="co">## use match() to lookup the marriage id of each person (in opop)'s</span></span>
<span><span class="co">## first marriage id</span></span>
<span><span class="va">opop</span><span class="op">[</span><span class="va">opop</span><span class="op">$</span><span class="va">fem</span><span class="op">==</span><span class="fl">0</span>,<span class="st">"fmid"</span><span class="op">]</span><span class="op">&lt;-</span></span>
<span>  <span class="va">fomar</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/match.html" class="external-link">match</a></span><span class="op">(</span><span class="va">opop</span><span class="op">[</span><span class="va">opop</span><span class="op">$</span><span class="va">fem</span><span class="op">==</span><span class="fl">0</span>,<span class="st">"pid"</span><span class="op">]</span>,<span class="va">fomar</span><span class="op">$</span><span class="va">hpid</span><span class="op">)</span>,<span class="st">"mid"</span><span class="op">]</span></span>
<span><span class="va">opop</span><span class="op">[</span><span class="va">opop</span><span class="op">$</span><span class="va">fem</span><span class="op">==</span><span class="fl">1</span>,<span class="st">"fmid"</span><span class="op">]</span><span class="op">&lt;-</span></span>
<span>  <span class="va">fomar</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/match.html" class="external-link">match</a></span><span class="op">(</span><span class="va">opop</span><span class="op">[</span><span class="va">opop</span><span class="op">$</span><span class="va">fem</span><span class="op">==</span><span class="fl">1</span>,<span class="st">"pid"</span><span class="op">]</span>,<span class="va">fomar</span><span class="op">$</span><span class="va">wpid</span><span class="op">)</span>,<span class="st">"mid"</span><span class="op">]</span></span></code></pre>
<p><span label="fig:firstMarriages">Figure 4: R code for finding first marriages labelfig:firstMarriages</span></p>
</div>
</div>
<div class="section level1">
<h1 id="transition-history-files">Transition history files<a class="anchor" aria-label="anchor" href="#transition-history-files"></a></h1>
<p>If group transitions are part of the simulation then socsim will write (and may read) a transition history file. In spirit, the <strong><em>otx</em></strong> file is much like the marriage file, the main differences are that the <strong><em>file</em></strong> is linked to only one person and there is no unique identifier for a transition history record.</p>
<p>Like all other Socsim output files, the <strong><em>otx</em></strong> file is space delimited and contains only numbers. Table <a href="#tab:otxformat">[tab:otxformat]</a> shows the structure of the <strong><em>otx</em></strong> file. Figure <a href="#fig:otxread">[fig:otxread]</a> contains R code for reading an otx file into a data frame.</p>
<table class="table"><colgroup><col width="4%"><col width="2%"><col width="92%"></colgroup><thead><tr class="header"><th align="right"><strong>position</strong></th>
<th align="left"><strong>name</strong></th>
<th align="left"><strong>description</strong></th>
</tr></thead><tbody><tr class="odd"><td align="right">1</td>
<td align="left">pid</td>
<td align="left">Person id to who the transition event occurred</td>
</tr><tr class="even"><td align="right">2</td>
<td align="left">date</td>
<td align="left">Month in which the transtion occurred</td>
</tr><tr class="odd"><td align="right">3</td>
<td align="left">fromg</td>
<td align="left">group from which the person transitions</td>
</tr><tr class="even"><td align="right">4</td>
<td align="left">tog</td>
<td align="left">group into which the person transitions</td>
</tr><tr class="odd"><td align="right">5</td>
<td align="left">sequence</td>
<td align="left">a non positive number indicating the order of the event. A zero indicates that the current record refers to the most recent transition event; a -7 indicates that seven transitions have occurred to this person subsequent to that of the current record.</td>
</tr></tbody></table><p>Table 3: Contents and format of the .otx file<span label="tab:otxformat"></span></p>
<hr><p>Figure 5: R code for reading an otx file:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>otx<span class="ot">&lt;-</span><span class="fu">read.table</span>(<span class="at">file=</span><span class="st">"../SimResults/test.otx"</span>,<span class="at">header=</span>F,<span class="at">as.is=</span>T)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="fu">names</span>(otx)<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"pid"</span>,<span class="st">"month"</span>,<span class="st">"fromg"</span>,<span class="st">"tog"</span>,<span class="st">"pnum"</span>)</span></code></pre></div>
</div>
<div class="section level1">
<h1 id="specifying-demographic-rates">Specifying demographic rates<a class="anchor" aria-label="anchor" href="#specifying-demographic-rates"></a></h1>
<p>It is most convenient to store demographic rates for each simulation segment in distinct files and use the <span class="upright"><code>include</code></span> directive to reference them from the supervisory file (See Section <a href="#sec:supFile">4</a>). But regardless of how you choose to organize your rate files, you will need to assemble a large collection of rates. How Socsim expects those rates to be formatted is described in Section <a href="#sec:vitalRates">8.2</a>, but before we get to that Section <a href="#sec:rateDefault">8.1</a> describes the rules Socsim follows when it encounters incomplete rate sets. These are important to understand, because Socsim does not warn you when for example you leave out fertility rates for parity 1 divorced females of group 3 (birth 3 F divorced 1). Instead, it “defaults” to rates for party 0 divorced females of group 3 (birth 3 F divorced 0). Similarly if the birth 3 F divorced 0 rates are missing, Socsim uses birth 3 F single 0) in their place. The rules are fairly intuitive, but its important to understand that one can err by not specifying that certain rates are zero.</p>
<div class="section level2">
<h2 id="rate-default-rules">Rate default rules<a class="anchor" aria-label="anchor" href="#rate-default-rules"></a></h2>
<p>To run a moderately realistic simulation, Socsim requires age specific fertility rates for females and mortality rates for both males and females of each <strong><em>group</em></strong> and marital status. If rates do not differ by marital status or group then you can use Socsim’s default rules to avoid entering the same blocks of rates repeatedly. When Socsim encounters incomplete rates sets, it follows a set of rules to determine how the blanks are to be filled in. Figure <a href="#fig:rateDefaults">[fig:rateDefaults]</a> shows the rules that Socsim uses when it encounters incomplete rate sets. The “==&gt;” symbol in Figure <a href="#fig:rateDefaults">[fig:rateDefaults]</a> means “defaults to” so for example,</p>
<pre><code>widowed                  ==&gt; divorced; parity 0; group 1</code></pre>
<p>which appears in the “Fertility Rates” section under the heading “For parity zero women in group 1” indicates that if Socsim does not find fertility rates for parity zero, widowed females in group 1 it will “default to” the rates for divorced women of parity zero and group 1.</p>
<p>Where Figure <a href="#fig:rateDefaults">[fig:rateDefaults]</a> indicates that a rate block defaults to “Zero”, Socsim does not default to anything leaving such events with zero probability of occurring at any age. So for example, unless you think that single males in group 1 should live forever, you must specify mortality rates for such “people”.</p>
<p><span id="fig:rateDefaults" label="fig:rateDefaults">[fig:rateDefaults]</span></p>
<p><strong>Fertility Rates</strong></p>
<pre><code>
For parity zero women in group 1
--------------------------------
single                          ==&gt; Zero
married                         ==&gt; Zero
divorced                        ==&gt; single; parity 0; group 1
widowed                         ==&gt; divorced; parity 0; group 1
cohabiting                      ==&gt;  married; parity 0; group 1

For women in group 1 with higher parity
------------------------------------------
mstatus m; PARITY P; group 1     ==&gt; mstatus m; PARITY P-1; group 1

For women of any parity and any group &gt; 1

mstatus m; parity  p; GROUP  G   ==&gt;  mstatus m; parity p; GROUP G-1</code></pre>
<p><strong>Marriage, Divorce and Mortality Rates</strong></p>
<pre><code>
For men and women in group
-----------------------------------
DEATH    for single; sex s; group 1       ==&gt; Zero
MARRIAGE for single; sex s; group 1       ==&gt; Zero
DIVORCE  for mstatus m; sex s; group 1    ==&gt; Zero

  (Events except for divorce)
-----------------------------
event e for divorced;sex s    ==&gt;  event e; for single;sex s;group 1
event e for widowed;sex s     ==&gt;  event e; for divorced;sex s;group 1
event e for married;sex s     ==&gt;  event e; for widowed;sex s;group 1
event e for cohabitting;sex s ==&gt;   event e; for married;sex s;group 1

For Groups &gt; 1
--------------
event e for mstatus m;sex s; group g ==&gt; event e for mstatus m;sex s; group g-1</code></pre>
<p><strong>Group Transition Rates</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>TRANSITTION to group H <span class="cf">for</span> mstatus m;sex s; group g <span class="sc">==</span> Zero</span></code></pre></div>
</div>
<div class="section level2">
<h2 id="structure-of-vital-rates">Structure of vital rates<a class="anchor" aria-label="anchor" href="#structure-of-vital-rates"></a></h2>
<p>The format in which Socsim expects to find rates is simple. Each <strong><em>block</em></strong> of rates begins with a set of keywords which indicate the event for which the rates apply and the marital status, sex, group membership and possibly parity of the people who are at risk of experiencing the event. That information is followed on subsequent lines of rate values and the <strong>upper bound</strong> of the age group for which the rate is in force.</p>
<p>A <strong><em>rate block</em></strong> is a complete set of age specific rates governing a demographic event for people of a particular sex,group and marital status. An example of a rate block is shown in Figure <a href="#fig:rateBlock">[fig:rateBlock]</a>. The first line after the comment line, indicates which event (death); group (1); sex (M=male); and marital status (single) this rate block pertains to. The order matters and is always, Event then group then sex then marital status. In the case of birth rates this may be followed by number indicating parity. In the case of transition rates, the line must end with a number indicating the destination group.</p>
<p>Each subsequent line contains a one month rate (in the case of fertility) or a one month probability in the case of all other events, and the age interval over which the monthly rate (probability) holds. The first two numbers in the line are years and months of the upper age bound. These are added together so a 1 and 11 would mean 23 months. The third number is the rate. In the case of fertility it represents the expected number of births <strong>per month</strong> to a woman who survives to end of the given age interval. Specifically – The interval that includes upper age bound given in the previous line and ends just before the upper age bound given on the <strong>current line</strong>.</p>
<p>Figure <a href="#fig:rateBlock">[fig:rateBlock]</a> shows an example of rate block. The first line indicates that that rates which follow refer to mortality of group 1 single males (death 1 M single).</p>
<p>The first first rate line (<code>0 1 .0460940</code>) indicates that the probability of death in the first month of life for males (technically for never married males) is .0460940. Note that a rate line with an upper age bound of “0 0” is meaningless and is ignored. So be careful when specifying infant mortality rates.</p>
<p>Taking another line from Figure <a href="#fig:rateBlock">[fig:rateBlock]</a>, the probability that a single male dies between the ages of 1141 and 1200 months, conditional on having survived to the beginning of the age interval is (1-(1-.08326)^{60}).</p>
<p><span id="fig:rateBlock" label="fig:rateBlock">[fig:rateBlock]</span></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="sc">*</span>Mortality, single <span class="fu">Male</span> (lines beginning with <span class="sc">*</span> are comments)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>death <span class="dv">1</span> M single</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">1</span>       .<span class="dv">0460940</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">12</span>      .<span class="dv">0057540</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">60</span>      .<span class="dv">0008730</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">120</span>     .<span class="dv">0002600</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>.</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>.</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>.</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">1140</span>    .<span class="dv">0832630</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="dv">0</span>       <span class="dv">1200</span>    .<span class="dv">0832630</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="mortality-rates">Mortality rates<a class="anchor" aria-label="anchor" href="#mortality-rates"></a></h2>
<p>Mortality rates are the most straight forward of the rates that Socsim uses. The example in Figure <a href="#fig:rateBlock">[fig:rateBlock]</a> is typical. The event identifier is <span class="upright"><code>death</code></span>, the “1” refers to the group, “M” to male and “single” is of course marital status.</p>
</div>
<div class="section level2">
<h2 id="marriage-rates">Marriage rates<a class="anchor" aria-label="anchor" href="#marriage-rates"></a></h2>
<p>Marriage rates are specified with the event identifier of <span class="upright"><code>marriage</code></span>, but it should be born in mind the event which these rates regulate is not really marriage but rather the commencement of a marriage search. Since marriage requires two participants Socsim cannot simply execute a marriage when the event is scheduled. Marriage requires two participants and such it is very difficult to achieve arbitrarily specified marriage rates for both males and females. If a marriage age distribution is also part of the simulation, it gets even harder. Socsim deals with this in a variety of ways which are described in Section <a href="#sec:marriageQueue">3</a> and Section <a href="#sec:supFile">4</a>.</p>
<p>As a consequence, of all this excuse making is that marriage rates often need to be “tuned” in order to achieve the desired result.</p>
</div>
<div class="section level2">
<h2 id="divorce-rates">Divorce rates<a class="anchor" aria-label="anchor" href="#divorce-rates"></a></h2>
<p>Divorce rates are specified with the event identifier <span class="upright"><code>divorce</code></span>. Divorce is unusual among Socsim events in that it’s rates do not apply to the age of one spouse or the other but rather by age of the marriage. It is thus generally not necessary to specify divorce rates for both sexes.</p>
</div>
<div class="section level2">
<h2 id="fertility-rates">Fertility rates<a class="anchor" aria-label="anchor" href="#fertility-rates"></a></h2>
<p>Fertility rates are specified with the identifier <span class="upright"><code>birth</code></span> and are different from other rates in two ways:</p>
<ol style="list-style-type: decimal"><li><p>They are parity specific. But they default to parity (n-1) so it is only necessary to specify rates for parity zero.</p></li>
<li><p>They are rates rather than probabilities. So multiplying a rate by the number of months in the age category gives the expected number of births that a woman who lives through the age category will experience.</p></li>
</ol></div>
<div class="section level2">
<h2 id="transition-rates">Transition rates<a class="anchor" aria-label="anchor" href="#transition-rates"></a></h2>
<p>Transition rates give rates of “transition” from one <strong><em>group</em></strong> to another. By default, no transitions occur, however, if the initial population contains more than one group then the group inheritance rule determines the group identity of new borns.</p>
<p>Transition rates are specified with the identifier <span class="upright"><code>transit</code></span> and are different from other rates in that both the group to which the rate applies <strong>and</strong> the group to which the event will cause a person to belong must be specified.</p>
<p>To specify transition rates from group 1 to group 2 for single males, one would write the following:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>trasit <span class="dv">1</span> M single <span class="dv">2</span>  </span></code></pre></div>
<p>As noted in Figure <a href="#fig:rateDefaults">[fig:rateDefaults]</a>, transition rates have no defaults. All rates have to be specified in order to take effect.</p>
<div class="section level3">
<h3 id="duration-specific-transition-rates">Duration specific transition rates<a class="anchor" aria-label="anchor" href="#duration-specific-transition-rates"></a></h3>
<p>It is often useful for transition rates to be duration rather than age specific. In other words, the probability of a transition event occurring can depend on the time since the individual transitioned into the current group rather than the individual’s age. In order for this distinction to matter, a person must have experienced at least one transition other wise the time spent in the group is equivalent to the person’s age.</p>
<p>Divorce rates are always duration specific, but transition rates may vary with either age or duration. The format for specifying transition rate blocks is the same regardless of whether they are age or duration specific. To tell Socsim that a particular rate block is meant to be duration specific, add the directive: <span class="upright"><code>duration_specific</code></span> as in:</p>
<p>duration_specific transit 4 F married 5</p>
<p>when this directive is encountered, the log file will indicate that transition rates from group 4 to group 5 for married females will be duration rather than age specific. The default is for transition rates to be age specific so no indication is given in the log file of that condition. It is possible to have both age and duration specific transition rates in effect in the same simulation, however, only one transition rate block is allowed per pair of groups. So transitions from say group 3 to group 5 for single males must be <em>either</em> age or duration specific, but whichever it is, has no effect on transitions from group 3 to group 5 for <strong><em>married</em></strong> males. One may be age specific while the other may be duration specific.</p>
<p>As noted in Section <a href="#sec:segmentSpecific">4.4</a>, the <span class="upright"><code>duration_specific</code></span> directive does not replace the keywords that define the rate block.</p>
</div>
</div>
<div class="section level2">
<h2 id="event-competition">Event competition<a class="anchor" aria-label="anchor" href="#event-competition"></a></h2>
<p>At the start of every month in the simulation, every living person has exactly one event scheduled for some future date. In the course of this month, all scheduled events are executed. Events affect the individuals for whom they are scheduled but may also affect spouses and others to whom they are connected. All births, deaths, marriages and group transitions that are scheduled for the current month are executed in random order. After a person’s event is executed, unless that event was death, a new event must be scheduled. New events are scheduled by an “event competition.” This event competition is also held once for each living person at the beginning of each simulation segment (that is, every time the demographic rates or societal constants change).</p>
<p>Each event for which the individual is at risk (e.g., men rarely give birth) can be modeled as a piecewise exponential distribution. A random number is used to generate a waiting time until this event occurs (which is bounded by the individual’s maximum possible age at death). The individual’s next event is the one with the shortest randomly generated waiting time. The event competition thus follows a competing risk framework wherein the probability of each event is independent of all others.</p>
</div>
<div class="section level2">
<h2 id="generating-potential-waiting-times">Generating potential waiting times<a class="anchor" aria-label="anchor" href="#generating-potential-waiting-times"></a></h2>
<p>The waiting time algorithm is conceptually equivalent to drawing a random number u, from a uniform (0,1) distribution, calling u the probability that the event will not yet have occurred, then finding the first month by which the probability of non-occurrence is less than or equal to u. The probability that an event will not have occurred by a particular month T is given by the expression</p>
<p>[ <em>{t=0..T} (1-p</em>{t})]</p>
<p>Y_(t=0…T) (1 − p_t)</p>
<p>Where (p_t) is the probability of the event’s occurrence in period t conditioned on it not having occurred at any time before t. Since (1-p_t) is always between 0 and 1, the expression given above is nonincreasing in (T). Consequently, beginning with (t = 0) we can successively multiply the (1-p_t) terms together until the value of the product falls below u. What Socsim does is mathematically equivalent to this procedure, however, the implementation in function <code>datev</code> takes advantage of fact that the probabilities can be the same over months or years and works with powers of ((1-p_t).</p>
</div>
</div>
<div class="section level1">
<h1 id="heterogeneity-multipliers">Heterogeneity multipliers<a class="anchor" aria-label="anchor" href="#heterogeneity-multipliers"></a></h1>
<p>Heterogeneity beyond that which follows from the algorithm described in Section <a href="#sec:datev">8.9</a> is often desirable in microsimulation. Socsim increases heterogeneity of fertility for example, in order to create more realistic sibling set sizes and to allow for heritability of fertility.</p>
<p>Heterogeneity of mortality and group transitions are not included by default but much code is in place to allow users to add these features easily in a way that makes sense for a particular simulation.</p>
<p>The general principle is that if each person at risk of an event is given a value () drawn from a distribution with mean=1 and the hazard rates used for generating each individual’s waiting time for the event are multiplied by (), then (E(h)=h). Where (h) is the original hazard of the event. Thus the overall population’s event history should still reflect the rate structure but with greater variance/heterogeneity.</p>
<div class="section level2">
<h2 id="fertility-multiplier-fmult">Fertility multiplier (fmult)<a class="anchor" aria-label="anchor" href="#fertility-multiplier-fmult"></a></h2>
<p>When the heterogeneous fertility option,(<strong><em>hetfert</em></strong>) is enabled, each female in the population is assigned a fertility multiplier. For the initial population these multipliers may be read in the <strong><em>.opop</em></strong> file or they may be generated by Socsim. Females born during the simulation will have multipliers generated by Socsim. Once assigned, fertility multipliers remain with the woman for her entire life increasing or reducing proportionally the hazard of giving birth at each.</p>
<p>In the current implementation, individual fertility multipliers, <strong><em>fmult</em></strong>s, are pseudorandomly distributed as a cubic approximation to the beta distribution with mean 1.0, variance 0.416, and a range of 0 to 2.4. Fertility heterogeneity is also heritable to a degree determined by the user specified directives <span class="upright"><code>alpha</code></span> and <span class="upright"><code>beta</code></span>.</p>
</div>
<div class="section level2">
<h2 id="inheritance-of-fertility-multipliers">Inheritance of Fertility Multipliers<a class="anchor" aria-label="anchor" href="#inheritance-of-fertility-multipliers"></a></h2>
<p>The degree to which heterogeneous fertility is inherited is determined by the <span class="upright"><code>alpha</code></span> (()) and <span class="upright"><code>beta</code></span> (()) directives. Equation <a href="#eq:inheritfert">[eq:inheritfert]</a> defines the algorithm used to effect the inheritance. At birth females are first assigned a fertility multiplier as according to the beta distribution described in Section <a href="#sec:fmult">9.1</a> this is () in Equation <a href="#eq:inheritfert">[eq:inheritfert]</a>. The temporary variable (x) gets the () weighted average of () and ego’s mother’s fertility multiplier. If () then (x) is the daughter’s fertility multiplier. Otherwise it is further modified by the second equation.</p>
[
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>x</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo></mtd><mtd columnalign="right" style="text-align: right"><mi>α</mi><mo>*</mo><msub><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>*</mo><mi>γ</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">t</mi></mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">g</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo></mtd><mtd columnalign="right" style="text-align: right"><mn>2.5</mn><mo>*</mo><msup><mo>exp</mo><mrow><mi>β</mi><mo>*</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mi>x</mi><mn>2.5</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
  x &amp;=&amp; \alpha *\mathrm{fmult}_{\mathrm{mother}} + (1-\alpha)*\gamma\\
\label{eq:inheritfert}
  \mathrm{fmult}_{\mathrm{daughter}} &amp;=&amp; 2.5* \exp^{\beta*log(\frac{x}{2.5})} \end{aligned}</annotation></semantics></math><p>]</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode R"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>[<span class="dv">4</span>]<span class="sc">:</span>    x <span class="ot">=</span> α ∗ fmult_mother <span class="sc">+</span> (<span class="dv">1</span> − α) ∗ γ </span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>(<span class="dv">5</span>)    fmult_daughter <span class="ot">=</span> <span class="fl">2.5</span> ∗ <span class="fu">exp</span> (β∗<span class="fu">log</span>(x<span class="sc">/</span><span class="fl">2.5</span> ))</span></code></pre></div>
<p><b id="f1">[1]</b> to the extent that there is a “plan” <a href="#a1">↩︎</a></p>
<p><b id="f2">[2]</b> Groups are a additional category that can be used to extend Socsim in interesting ways. Groups are described in a little more detail in Section <a href="#sec:groups">2.1</a> <a href="#a2">↩︎</a></p>
<p><b id="f3">[3] </b>One <strong>can</strong> start Socsim with an initial population complete with a kin network, but typically the purpose of this whole exercise is to generate a simulated a kinship network. <a href="#a3">↩︎</a></p>
<p><b id="f4">[4] </b>A simulation segment is a period of simulated time during which a single set of vital rates are in effect <a href="#a4">↩︎</a></p>
<p><b id="f5">[5] </b> Socsim, does not yet handle same sex marriage. Sorry! <a href="#a5">↩︎</a></p>
<p><b id="f6">[6] </b>It may also read and write a file of extra variables and a file of transition history <a href="#a6">↩︎</a></p>
<p><b id="f7">[7] </b> It is best practice not to rely on the .opop file’s pid ordering because this convention can be broken in the initial population file <a href="#a7">↩︎</a></p>
</div>
</div>


  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Tom Theile, Diego Alburez-Gutierrez, Mallika Snyder, Liliana P. Calderón-Bernal.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

